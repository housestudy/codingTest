# 내 답... ㅋ
# 그래도 실버 1인데 이럴리가 없지...
a, b, c = map(int, input().split())

print(a ** b % c)

# 답
# 아예 처음 보는 개념이다.
# DAC라고 Divide and Conquer 즉, 분할 정복의 원리를 사용해야 한다.
# 예를 들어, 2^32 라면 2를 32번 곱하기보단, (2^16)^2 를 하면 17번의 연산만 하면 된다.
# 이를 계속 분할하다보면 (((2^4)^2)^2)^2 처럼 7번 만에도 끝낼 수 있다.
# 문제에서 B가 21억 이하의 자연수이기 때문에 내 답처럼 하면 연산이 21억을 넘길 수도 있다.
def dac(a, b, c):
    if b == 1:
        # b가 1이면 어떤 수든 1승은 자기 자신이기 때문에 그냥 a % c
        return a % c
    elif b % 2 == 0:
        # b가 짝수면, a의 b // 2 승을 해준 뒤, 다시 2를 제곱해준다.
        # 예를 들어 2^32%4 라면 (2^16)^2 % 4 를 해줘야 한다.
        return (dac(a, b // 2, c) ** 2) % c
    else:
        # b가 홀수면, a의 b // 2 승을 해준 뒤, 2를 제곱하고 다시 a를 곱해 a의 b승을 만들어준다.
        # 예를 들어 2^33%4 라면 (2^16)^2*2 % 4 를 해줘야 한다.
        return ((dac(a, b // 2, c) ** 2) * a) % c

a, b, c = map(int, input().split())
print(dac(a, b, c))